// var arr = [1, 2, 3, 4, 5];
// for (i = 0; i < arr.length; i++) {
//     console.log(i, '下标');
//     console.log(arr[i], '第' + (i + 1) + '数组元素');
// }

// 求和 1-100偶数和 2550 
// var result =0;
// for(i=0;i<=100;i++){
// 	// 偶数除2没有余数 
// 	if(i%2==0){
// 		result+=i;
// 	}
// 	// 1-100奇数和
// 	// if(i%2!=0){
// 	// 	result+=i
// 	// }
// }
// console.log(result);

// 冒泡排序 
//1、比较相邻的两个元素，如果前一个比后一个大，则交换位置。
//2、比较完第一轮的时候，最后一个元素是最大的元素。
//3、这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。
// 使用双层for循环 实现冒泡排序 

// 分析 外面轮数 
// 第一轮: 20 21 [20,21,18,23,9,17]
// 			 21 18 [20,18,21,23,9,17]
// 			 21 23 [20,18,21,23,9,17]
// 			 23 9  [20,18,21,9,23,17]
// 			 23 17 [20,18,21,9,17,23]
// 第二轮: 20 18 [18,20,21,9,17,23]
// 				20 21 [18,20,21,9,17,23]
// 				21 9 [18,20,9,21,17,23]
// 				21 17 [18,20,9,17,21,23]
// 第三轮: 18 20 [18,20,9,17,21,23]
// 				20 9 [18,9,20,17,21,23]
// 				20 17 [18,9,17,20,21,23]
// 第四论: 18 9  [9,18,17,20,21,23]
// 				18 17 [9,17,18,20,21,23]
// 第五轮: 9 17 [9,17,18,20,21,23]

// var arr = [20, 21, 18, 23, 9, 17];//从小到大排列 外部比较几轮 内部每一轮比较多少次
// var len = arr.length;
// function bSort(){
// for (i = 0; i < len - 1; i++) {
//     for (j = 0; j < len - 1 - i; j++) {
//         if (arr[j] > arr[j + 1]) {
//             var temp = arr[j];
//             arr[j] = arr[j + 1];
//             arr[j + 1] = temp;
//         }
//     }
// } return arr
// }
// bSort(arr);
// console.log(arr);

for (i = 0; i < 100; i++) {
    console.log(i);
    if (i == 5) {
        break;
    }
}